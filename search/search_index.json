{"config":{"lang":["es"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> .browserslistrc<pre><code>theme:\n  features:\n    - content.code.annotate # (1) \n      # code # (1) #hola\n</code></pre> <ol> <li> I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</li> </ol> CC++ <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n  printf(\"Hello world!\\n\");\n  return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\n  std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n  return 0;\n}\n      // code # (1) #hola\n</code></pre> <ol> <li> I'm a code annotation! I can contain <code>code</code>, formatted text, images, ... basically anything that can be written in Markdown.</li> </ol> <p>The HTML is great</p> <p>Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit.</p> <ol> <li> I'm an annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be expressed in Markdown.</li> </ol> <p>Ctrl+Alt+Del</p> <ul> <li> HTML for content and structure</li> <li> JavaScript for interactivity</li> <li> CSS for text running out of boxes</li> <li> Internet Explorer ... huh?</li> </ul> <p> </p> Image caption .browserslistrc<pre><code>theme:\n  features:\n    - content.code.annotate # (1) \n      # code # (1) #hola\n</code></pre> <ol> <li>Enter a few keywords to find the perfect icon using our mkdocs.org and click on the shortcode to copy it to your clipboard:</li> </ol> 1 / 4 2 / 4 Caption 3 / 4 Caption Three 4 / 4 Caption Three \u276e \u276f"},{"location":"blog/","title":"Blog","text":""},{"location":"gitlab0001/gitlab0001/","title":"Bienvenidos a GitLab","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"gitlab0001/gitlab0001/#commands","title":"Commands","text":"<p>Aqu\u00ed tedremos las pipelines y los jobs y tambi\u00e9n el pipeline y el job</p> 1 / 4 Caption Text 2 / 4 Caption 3 / 4 Caption Three 4 / 4 Caption Three \u276e \u276f 1 / 4 Caption Text 2 / 4 Caption Two 3 / 4 Caption Three 4 / 4 Caption Three \u276e \u276f 1 / 4 Caption Text 2 / 4 Caption Two 3 / 4 Caption Three 4 / 4 Caption Three \u276e \u276f"},{"location":"gitlab0007/gitlab0007/","title":"C\u00f3digo de aplicaci\u00f3n alojado en el repositorio Git","text":""},{"location":"gitlab0008/gitlab0008/","title":"Stages, Groups y Jobs","text":"<p>Ahora hay una cosa m\u00e1s que optimizar en nuestro pipeline simple en este momento.</p> <p>Nuevamente, si volvemos a la secci\u00f3n CI/CD y a las pipelines y visualizamos los jobs en una pipeline, veremos que todos estos pasos o todos los jobs se ejecutaron en un stage, que de forma predeterminada se denomina <code>test</code>.</p> 1 / 4 Caption Text 2 / 4 Caption 3 / 4 Caption Three 4 / 4 Caption Three \u276e \u276f <p>Nosotros no configuramos este nombre, esto es lo que nos ofrece GitLab CI/CD por defecto. Y eso significa que cuando tenemos jobs ejecutados b\u00e1sicamente en un solo stage , se ejecutan en paralelo. Entonces, cuando ejecutamos la pipeline, estos tres jobs se ejecutar\u00e1n en paralelo.</p> <p>Sin embargo, eso no es lo que queremos porque, por supuesto, cuando ejecutamos el pipeline queremos ejecutarlo en un orden determinado y b\u00e1sicamente tener los stages por las que pasa el pipeline.</p> <p>Por lo tanto, queremos crear la imagen solo despu\u00e9s de que se hayan ejecutado las pruebas y queremos enviar la imagen solo despu\u00e9s de haberla creado porque, de lo contrario, no tendremos nada que enviar.</p> <p></p> <p>Por lo tanto, estos jobs no deber\u00edan ejecutarse en paralelo, deber\u00edan ejecutarse en orden: ejecutar la prueba, luego crear la imagen y luego enviar la imagen.</p> <p></p> <p>Y si tuvi\u00e9ramos un deploy job aqu\u00ed, entonces querr\u00edamos que el deploy se ejecutara despu\u00e9s de haber enviado la imagen al repositorio. Ahora tenemos una nueva imagen que podemos recuperar u obtenerla del repositorio para implementarla en el servidor.</p> <p>Y adem\u00e1s de eso, si uno de los jobs falla, por ejemplo si el job de creaci\u00f3n de imagen falla como lo hemos hecho en esta ejecuci\u00f3n de la pipeline, entonces los siguientes jobs no deber\u00edan ejecutarse porque no tiene sentido enviar una imagen que no fue compilada con \u00e9xito, o no tiene sentido implementar cambios en la aplicaci\u00f3n si no creamos una nueva imagen y la enviamos al repositorio.</p> <p>As\u00ed que todos los pasos siguientes deben ser omitidos cuando uno de los jobs falla. Y si todos los jobs se ejecutan en el mismo stage, veremos que no tenemos esa imagen de compliaci\u00f3n fallida. Sin embargo, <code>push_image</code> se ejecut\u00f3 (1)</p> <p>Entonces, para estos casos de uso tenemos otro concepto en GitLab CI/CD que se llama stages. Y, por lo general, con la mayor\u00eda de las pipelines de aplicaciones trabajaremos con esos stages. Y con los stages tambi\u00e9n podemos agrupar l\u00f3gicamente varios jobs que van juntos.</p> <p>Por ejemplo, si ejecutamos varias pruebas para la aplicaci\u00f3n, podemos tener un stage de prueba que ejecute pruebas unitarias y pruebas funcionales, por ejemplo.(1)</p>"}]}